<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Research & Project Timeline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue",
        Arial, "Noto Sans", sans-serif;
    }

    body {
      background: #f4f5f7;
      color: #222;
    }

    .page {
      max-width: 900px;
      margin: 40px auto;
      padding: 0 16px 60px;
    }

    h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 4px;
      text-align: center;
    }

    .subtitle {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin-bottom: 24px;
    }

    .timeline-wrapper {
      position: relative;
      margin: 0 auto;
      max-width: 760px;
      padding: 24px 0;
    }

    .timeline {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* Central axis */
    .timeline::before {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(to bottom, #d7dde5, #c0c6d4);
    }

    /* Shared tick style */
    .time-tick {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      pointer-events: none;
    }

    .time-tick::before {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 0;
      background: #bbb;
    }

    /* Year ticks */
    .time-tick-year::before {
      width: 16px;
      height: 3px;
      background: #9ca3af;
    }

    /* Month ticks */
    .time-tick-month::before {
      width: 10px;
      height: 1px;
      background: #d1d5db;
    }

    /* Year label (large, faint) */
    .time-tick-label-year {
      position: absolute;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 44px;
      font-weight: 700;
      letter-spacing: 0.12em;
      color: rgba(148, 163, 184, 0.28);
    }

    /* Month label (smaller, faint) */
    .time-tick-label-month {
      position: absolute;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 26px;
      font-weight: 600;
      letter-spacing: 0.06em;
      color: rgba(148, 163, 184, 0.40);
    }

    /* Event line core */
    .event-line-core {
      position: absolute;
      width: 6px;
      border-radius: 999px;
      background: var(--color);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.04);
      cursor: pointer;
    }

    /* Start/end date pill */
    .date-label {
      position: absolute;
      font-size: 10px;
      color: #6b7280;
      background: #f9fafb;
      padding: 1px 4px;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.15);
      white-space: nowrap;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.18s ease, transform 0.18s ease;
    }

    /* Event summary card */
    .event-card {
      position: absolute;
      width: 260px;
      border-radius: 6px;
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 6px 10px;
      transform: translateY(-50%);
      z-index: 2;
      cursor: pointer;
      background: #ffffff;
    }

    /* Institution pills row */
    .event-institutions {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 4px;
    }

    .inst-pill {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.04em;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.15);
      background: rgba(15, 23, 42, 0.06);
      color: #111827;
    }

    .event-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .event-subtitle {
      font-size: 12px;
      color: #555;
      margin-bottom: 2px;
    }

    .event-dates {
      font-size: 11px;
      color: #888;
    }

    /* Dashed leader line from axis to card */
    .leader-line {
      position: absolute;
      height: 0;
      border-top: 1px dashed var(--color);
      cursor: pointer;
    }

    /* Shared interaction states */
    .event-piece {
      transition: opacity 0.18s ease, transform 0.18s ease,
                  box-shadow 0.18s ease, width 0.18s ease,
                  border-color 0.18s ease, background-color 0.18s ease;
    }

    .event-piece.dimmed {
      opacity: 0.18;
    }

    .event-card.active {
      transform: translateY(-50%) scale(1.04);
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
      z-index: 30;
    }

    .event-line-core.active {
      width: 8px;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.18);
    }

    .leader-line.active {
      border-top-style: solid;
    }

    .date-label.active {
      opacity: 1;
      font-weight: 600;
    }

    /* Floating detail panel (hover) */
    .detail-floating {
      position: absolute;
      width: 420px;
      padding: 12px 16px;
      border-radius: 8px;
      background: #e5e7eb;
      border: 1px solid #d1d5db;
      font-size: 13px;
      line-height: 1.5;
      transform: translateY(-50%);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.25);
      transition: background-color 0.18s ease, border-color 0.18s ease,
                  box-shadow 0.18s ease, opacity 0.18s ease;
      pointer-events: none;
      opacity: 0;
      z-index: 50;
    }

    .detail-media {
      position: absolute;
      padding: 6px;
      border-radius: 8px;
      background: #f9fafb;
      border: 1px solid #d1d5db;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.2);
      pointer-events: none;
      opacity: 0;
      z-index: 45;
      transform: translate(-50%, -50%);
    }

    .detail-media img {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 6px;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.2);
      object-fit: contain;
    }

    .detail-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .detail-subtitle {
      font-size: 13px;
      color: #4b5563;
      margin-bottom: 2px;
    }

    .detail-dates {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 8px;
    }

    .detail-body {
      font-size: 13px;
      color: #111827;
    }

    .detail-body-text {
      column-count: 1;
      column-gap: 0;
    }

    /* Detail body typography helpers */
    .detail-body-text p {
      margin: 6px 0;
    }

    .detail-body-text ul {
      margin: 6px 0 0 18px;
    }

    .detail-body-text li {
      margin: 3px 0;
    }

    .detail-body-text a {
      color: #0f172a;
      text-decoration: underline;
    }

    .detail-body-text .meta {
      font-size: 12px;
      color: #374151;
    }

    .detail-body-text .section-title {
      font-weight: 700;
      margin: 8px 0 4px;
    }

    @media (max-width: 768px) {
      .timeline-wrapper {
        height: 1600px;
      }

      .event-card {
        width: 220px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>Timeline</h1>
    <div class="subtitle">Research · Internships · Projects</div>

    <div class="timeline-wrapper">
      <div class="timeline" id="timeline"></div>
      <div class="detail-floating" id="detail-floating"></div>
      <div class="detail-media" id="detail-media"></div>
    </div>
  </div>

  <script>
    // ===== Data =====
    const events = [
      {
        title: "(arXiv) Learning Physical Simulation with Historical Message-Passing Integration Transformer",
        subtitle: "Paper",
        start: "2024-01-01",
        end:   "2024-05-30",
        label: "2024.1 – 2024.5",
        color: "#9ca3af", // Failure · paper
        institutions: ["failure"],
        cardOffset: -60,
        detail: `
          <div class="section-title">Authors & Affiliations</div>
          <p><strong>Authors</strong>: <strong>Zeyi Xu</strong>, Yifei Li</p>
          <p><strong>Affiliations</strong>: Shanghai University; MIT CSAIL</p>

          <div class="section-title">Overview</div>
          <p>
            <strong>Historical Message-Passing Integration Transformer (HMIT)</strong> enhances MeshGraphNet by integrating two key components:
            <strong>HMPA</strong> and <strong>GFL</strong>.
          </p>
          <ul>
            <li>
              <strong>HMPA</strong> caches the first <em>M</em> message-passing states per node and uses feature-wise attention to alleviate over-squashing,
              uniformly reconstructing the full spectrum at linear cost.
            </li>
            <li>
              <strong>GFL</strong> projects predictions into the Laplacian eigenbasis and adaptively rescales low-frequency coefficients to correct spectral bias.
            </li>
          </ul>

          <div class="section-title">My Contribution</div>
          <p>
            Throughout the research, I handled literature review, method innovation, code development and testing, experimental design, and paper writing.
          </p>
          <p class="meta">
            Acknowledgement: Many thanks to
            <a href="https://scholar.google.com/citations?user=N4ejGnoAAAAJ&hl=en" target="_blank" rel="noopener noreferrer">Yifei Li</a>
            for guidance on research direction, overall process, and manuscript revisions.
          </p>

          <img src="HMIT.png" alt="HMIT figure" />
        `
      },
      {
        title: "(Program) Numerical Oil Painting Simulation",
        subtitle: "Research Intern",
        start: "2024-05-01",
        end:   "2024-09-30",
        label: "2024.5 – 2024.9",
        color: "#34d399", // SJTU · program
        institutions: ["SJTU"],
        cardOffset: -70,
        detail: `
          <div class="section-title">Scope</div>
          <ul>
            <li>
              Implemented physics-simulation modules using <strong>OpenGL compute shaders</strong>.
            </li>
            <li>
              Built <strong>brush splatting</strong> for pigment deposition and stroke accumulation.
            </li>
            <li>
              Implemented brush dynamics via <strong>Position-Based Dynamics (PBD)</strong> (brush tip / bristle behavior).
            </li>
            <li>
              Prototyped oil paint physics with both a <strong>2D height-field Navier–Stokes solver</strong> and the <strong>shallow-water equations</strong>.
            </li>
          </ul>

          <img src="oil_painting.png" alt="Oil painting simulation result" />
        `
      },
      {
        title: "(CVPR 2025) AMR-Transformer: Enabling Efficient Long-range Interaction for Complex Neural Fluid Simulation",
        subtitle: "Research Intern",
        start: "2024-07-01",
        end:   "2024-11-30",
        label: "2024.7 – 2024.11",
        color: "#f472b6", // SJTU · paper
        institutions: ["SJTU"],
        cardOffset: -70,
        detail: `
          <div class="section-title">Authors & Affiliations</div>
          <p>
            <strong>Authors</strong>:
            <strong>Zeyi Xu*</strong>, Jinfan Liu*, Kuangxu Chen, Ye Chen, Zhangli Hu, Bingbing Ni
          </p>
          <p class="meta">* Co-first authors.</p>
          <p><strong>Affiliations</strong>: Shanghai Jiao Tong University; Shanghai University; Shenzhen Technology University</p>

          <div class="section-title">Project Summary</div>
          <p>
            By combining traditional methods with modern deep learning techniques,
            <strong>AdaptiveMeshRefinement-Transformer (AMR-Transformer)</strong> employs an octree-based Adaptive Mesh Refinement algorithm alongside a Transformer.
            It aims to capture long-range dependencies while adaptively adjusting the number of input tokens.
          </p>

          <div class="section-title">My Contribution</div>
          <p>
            Throughout the research, I handled the literature review, method innovation, part of the code development and testing,
            experimental design, and paper writing.
          </p>

          <img src="AMRT.png" alt="AMR-Transformer figure" />
        `
      },
      {
        title: "AMR-MeshGraphNet",
        subtitle: "Experiment",
        start: "2024-07-01",
        end:   "2024-09-30",
        label: "2024.7 - 2024.9",
        color: "#9ca3af", // Failure - ablation
        institutions: ["failure"],
        cardOffset: -20,
        detail: `
          <div class="section-title">Overview</div>
          <p>
            Tried pairing <strong>MeshGraphNet</strong> with the AMR token generator, but the results lagged so it ultimately served only as the <strong>AMR-Transformer</strong> ablation.
          </p>
        `
      },
      {
        title: "Message-Passing Convolution Neural Network (MPCNN)",
        subtitle: "Experiment",
        start: "2024-11-01",
        end:   "2025-01-30",
        label: "2024.11 - 2025.1",
        color: "#9ca3af", // Failure - experiment
        institutions: ["failure"],
        cardOffset: -10,
        detail: `
          <div class="section-title">Overview</div>
          <p>
            <strong>Message-Passing Convolution Neural Network (MPCNN)</strong> (with
            <a href="https://scholar.google.com/citations?user=SMdBcsEAAAAJ&hl=en" target="_blank" rel="noopener noreferrer">Kuangxu Chen</a>)
            integrates a cross-shaped convolution kernel with message passing to efficiently process semi-structured meshes.
          </p>
          <p>
            Demonstrated superior efficiency compared to standalone CNN or GNN baselines while still exposing accuracy gaps that halted publication. The method is extremely similar to SubdivNet, but I didn't realize it at the time.
          </p>
        `
      },
      {
        title: "Differentiable CFD Architecture",
        subtitle: "Experiment",
        start: "2024-12-01",
        end:   "2025-03-30",
        label: "2024.12 - 2025.3",
        color: "#9ca3af", // Failure - framework
        institutions: ["failure"],
        cardOffset: -50,
        detail: `
          <div class="section-title">Overview</div>
          <p>
            Built a differentiable CFD architecture with
            <a href="https://scholar.google.com/citations?user=SMdBcsEAAAAJ&hl=en" target="_blank" rel="noopener noreferrer">Kuangxu Chen</a>
            and
            <a href="https://scholar.google.com/citations?user=N4ejGnoAAAAJ&hl=en" target="_blank" rel="noopener noreferrer">Yifei Li</a>
            to simulate compressible fluids on 2D regular grid.
          </p>
          <p>
            Implemented the solver in <strong>PyTorch</strong> so gradients flow through time marching, enabling supersonic fluid parameter optimization.
          </p>
        `
      },
      {
        title: "(Unpublished) One-shot Learning of Optimal Adaptive Meshes for Compressible Flows",
        subtitle: "Paper",
        start: "2025-03-01",
        end:   "2025-12-30",
        label: "2025.3 – 2025.12",
        color: "#ec4899", // Multi-institution · paper
        institutions: ["Iowa State University"],
        cardOffset: -120,
        detail: `
          <div class="section-title">Authors</div>
          <p>
            <strong>Zeyi Xu*</strong>, <strong>Jinfan Liu*</strong>, Ligong Han, Kuangxu Chen&#8224;, Han Gao&#8224;
          </p>
          <p class="meta">* Co-first authors. &#8224; Corresponding authors.</p>
          <div class="section-title">Affiliations</div>
          <ul>
            <li>Department of Aerospace Engineering, Iowa State University, Ames, Iowa 50011, USA</li>
            <li>Shanghai Jiao Tong University, Shanghai 200240, China</li>
            <li>MIT-IBM Watson AI Lab, Cambridge, MA 02142, USA</li>
            <li>College of Engineering Physics, Shenzhen Technology University, Shenzhen 518118, China</li>
          </ul>

          <div class="section-title">Status</div>
          <p>Unpublished (will be released after publication).</p>

          <img src="AR-PI_Transformer_KH.png" alt="Adaptive mesh figure" />
        `
      },
      {
        title: "(Program) Robot Indoor Navigation",
        subtitle: "Algorithm Intern · Research Assistant",
        start: "2025-07-01",
        end:   "2025-10-30",
        label: "2025.7 – 2025.10",
        color: "#84cc16", // TranscEngram/HKU · program
        institutions: ["TranscEngram", "HKU"],
        cardOffset: -55,
        detail: `
          <div class="section-title">Patent Projects</div>
          <ul>
            <li>
              <strong>Embodied intelligence memory navigation system powered by LLM reasoning</strong> — First inventor.
            </li>
            <li>
              <strong>Graph‑Guided Navigation CoT</strong>:
              an image-guided, hierarchical, event-driven Chain-of-Thought navigation method and system — First inventor.
            </li>
          </ul>
        `
      },
      {
        title: "(Under Review) Neural Modular Physics for Elastic Simulation",
        subtitle: "Remote Intern",
        start: "2025-09-01",
        end:   "2025-11-30",
        label: "2025.9 – 2025.11",
        color: "#db2777", // MIT · paper
        institutions: ["MIT"],
        cardOffset: -30,
        detail: `
          <div class="section-title">Authors & Affiliations</div>
          <p><strong>Authors</strong>: Yifei Li, Haixu Wu, <strong>Zeyi Xu</strong>, Tuur Stuyck, Wojciech Matusik</p>
          <p><strong>Affiliations</strong>: MIT CSAIL; Shanghai University</p>

          <div class="section-title">My Contribution</div>
          <p>
            Responsible for the experimental baselines, including implementation, benchmarking, and performance comparisons across competing methods.
          </p>

          <img src="NMP.png" alt="Neural Modular Physics figure" />
        `
      },
      {
        title: "(Program) AI Rigging & Skinning",
        subtitle: "Research Scientist Intern",
        start: "2025-09-01",
        end:   "2025-12-01",
        label: "2025.9 – 2025.12",
        color: "#22c55e", // meshy · program
        institutions: ["meshy"],
        cardOffset: -20,
        detail: `
          <div class="section-title">Scope</div>
          <ul>
            <li>Trained an auto-rigging model for humanoid meshes (skeleton binding).</li>
            <li>Trained a skinning / weight-binding model that generalizes to arbitrary meshes.</li>
            <li>Designed a pipeline to infer skeletons from videos and support downstream rigging.</li>
          </ul>
        `
      },
      {
        title: "(Program) Mesh Generation",
        subtitle: "Research Scientist Intern",
        start: "2025-12-01",
        end:   null,
        label: "2025.12 – present",
        color: "#16a34a", // meshy · program
        institutions: ["meshy"],
        cardOffset: -20,
        detail: `
          <div class="section-title">Note</div>
          <p>Details are confidential at this time.</p>
        `
      },
      {
        title: "(Program) GPU Parallel Adaptive Octree Mesh Extraction",
        subtitle: "Research Scientist Intern",
        start: "2025-12-01",
        end:   null,
        label: "2025.12 – present",
        color: "#15803d", // meshy · program
        institutions: ["meshy"],
        detail: `
          <div class="section-title">What I Built</div>
          <p>
            Implemented GPU-parallel adaptive octree mesh extraction in <strong>PyTorch</strong>, based on
            <em>Unconstrained Isosurface Extraction on Arbitrary Octrees</em>.
          </p>
          <ul>
            <li>
              On a workload with <strong>2.0M leaves</strong>, <strong>1.2M vertices</strong>, and <strong>3.2M faces</strong>,
              runtime dropped from ~<strong>20s</strong> (original C++ implementation) to ~<strong>1.5s</strong>.
            </li>
          </ul>

          <img src="ISO.png" alt="Isosurface extraction visualization" />
        `
      }
    ];

    const detailHeights = [];
    const detailPanelBottomOffset = -180; // positive pushes up, negative allows lower
    const detailMediaGap = 24; // horizontal distance between floating text and image
    const detailMediaVerticalGap = 24; // vertical gap when stacking image
    const detailMediaEdgeMargin = 32; // keep media away from wrapper edges
    const detailMediaBaseHeight = 400; // preferred rendered height before scaling
    const detailMediaFallbackAspect = 1.6;
    const detailMediaBoundaryOverflow = 120; // allow media to extend beyond wrapper edges vertically
    const detailMediaOverlapWeight = 1000;
    const detailMediaAbovePenalty = 15; // bias to keep images below the card when possible
    const detailMediaDistancePenalty = 0.2;
    function extractDetailBody(content) {
      const temp = document.createElement("div");
      temp.innerHTML = content || "";
      let mediaHtml = "";
      const img = temp.querySelector("img");
      if (img) {
        mediaHtml = img.outerHTML;
        img.remove();
      }
      return {
        text: temp.innerHTML,
        media: mediaHtml
      };
    }

    function buildDetailHtml(e, captureMedia = false) {
      const subtitleText = (e.institutions && e.institutions.length)
        ? e.institutions.join(" / ")
        : e.subtitle;
      const bodyContent = e.detail || "More details are available upon request.";
      const parts = extractDetailBody(bodyContent);

      if (captureMedia) {
        e.detailMedia = parts.media || "";
      }

      return `
        <div class="detail-title">${e.title}</div>
        <div class="detail-subtitle">${subtitleText}</div>
        <div class="detail-dates">${e.label}</div>
        <div class="detail-body">
          <div class="detail-body-text">${parts.text}</div>
        </div>
      `;
    }

    function measureDetailHeights() {
      const temp = document.createElement("div");
      temp.className = "detail-floating";
      temp.style.visibility = "hidden";
      temp.style.pointerEvents = "none";
      temp.style.opacity = "0";
      temp.style.position = "absolute";
      temp.style.left = "-9999px";
      temp.style.top = "0";
      temp.style.transform = "none";
      document.body.appendChild(temp);

      events.forEach((e, idx) => {
        temp.innerHTML = buildDetailHtml(e, true);
        detailHeights[idx] = temp.offsetHeight;
      });

      document.body.removeChild(temp);
    }

    function parseDate(dateStr) {
      return new Date(dateStr + "T00:00:00");
    }

    function formatDateLabel(d) {
      const y = d.getFullYear();
      const m = d.getMonth() + 1;
      return y + "." + m;
    }

    function hexToRgba(hex, alpha) {
      let c = hex.replace("#", "");
      if (c.length === 3) c = c.split("").map(ch => ch + ch).join("");
      const num = parseInt(c, 16);
      const r = (num >> 16) & 255;
      const g = (num >> 8) & 255;
      const b = num & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function monthIndexFromDate(d) {
      return d.getFullYear() * 12 + d.getMonth(); // 0-based
    }

    function yearFromMonthIndex(idx) {
      return Math.floor(idx / 12);
    }

    function monthFromMonthIndex(idx) {
      return idx % 12; // 0-based
    }

    let currentActiveId = null;
    let renderedEvents = [];

    function updateDetailPanel(eventId) {
      const panel = document.getElementById("detail-floating");
      const mediaPanel = document.getElementById("detail-media");
      if (!panel) return;

      if (!eventId) {
        panel.style.opacity = "0";
        panel.innerHTML = "";
        if (mediaPanel) {
          mediaPanel.style.opacity = "0";
          mediaPanel.innerHTML = "";
        }
        return;
      }

      const e = renderedEvents.find(ev => ev.eventId === eventId);
      if (!e) return;

      panel.innerHTML = buildDetailHtml(e);
      panel.style.opacity = "1";
      panel.style.borderColor = hexToRgba(e.color, 0.8);
      panel.style.backgroundColor = hexToRgba(e.color, 0.08);
      panel.style.left = e.detailLeft + "px";

      const wrapper = document.querySelector(".timeline-wrapper");
      const panelHeight = panel.offsetHeight;
      let topPosition = e.detailTop;
      let wrapperHeight = 0;

      if (wrapper) {
        wrapperHeight = parseFloat(wrapper.dataset.timelineHeight) || wrapper.offsetHeight || 0;
      }

      if (wrapper && panelHeight) {
        const margin = 24;
        const halfHeight = panelHeight / 2;
        const minTop = margin + halfHeight;
        const maxTop = wrapperHeight - margin - halfHeight - detailPanelBottomOffset;

        if (minTop <= maxTop) {
          topPosition = Math.min(Math.max(e.detailTop, minTop), maxTop);
        } else {
          topPosition = wrapperHeight / 2;
        }
      } else if (!wrapperHeight) {
        wrapperHeight = window.innerHeight;
      }

      const finalTop = topPosition;
      panel.style.top = finalTop + "px";

      if (mediaPanel) {
        const hasMedia = e.detailMedia && e.detailMedia.trim().length > 0;
        if (!hasMedia) {
          mediaPanel.style.opacity = "0";
          mediaPanel.innerHTML = "";
        } else {
          mediaPanel.innerHTML = e.detailMedia;
          const img = mediaPanel.querySelector("img");
          if (!img) {
            mediaPanel.style.opacity = "0";
            mediaPanel.innerHTML = "";
            return;
          }

          if (!img.complete) {
            img.addEventListener(
              "load",
              () => {
                if (currentActiveId === eventId) updateDetailPanel(eventId);
              },
              { once: true }
            );
          }

          const naturalWidth = img.naturalWidth || img.width || detailMediaBaseHeight * detailMediaFallbackAspect;
          const naturalHeight = img.naturalHeight || img.height || detailMediaBaseHeight;
          const aspect = naturalHeight ? naturalWidth / naturalHeight : detailMediaFallbackAspect;
          const baseHeight = detailMediaBaseHeight;
          const baseWidth = aspect * baseHeight;

          const setSize = (width, height) => {
            mediaPanel.style.width = width + "px";
            mediaPanel.style.height = height + "px";
            img.style.width = "100%";
            img.style.height = "100%";
          };

          const buildSizeWithPreferredHeight = (maxWidth, maxHeight) => {
            if ((isFinite(maxWidth) && maxWidth <= 0) || (isFinite(maxHeight) && maxHeight <= 0)) return null;
            const usableMaxHeight = isFinite(maxHeight) ? maxHeight : baseHeight;
            let height = Math.min(baseHeight, usableMaxHeight);
            let width = height * aspect;

            if (isFinite(maxWidth) && width > maxWidth) {
              width = maxWidth;
              height = width / aspect;
            }

            if (height <= 0 || width <= 0) return null;
            return { width, height };
          };

          const detailWidth = e.detailWidth || panel.offsetWidth || baseWidth;
          const detailCenterX = e.detailLeft + detailWidth / 2;
          const panelHalfHeight = (panelHeight || 0) / 2;
          const panelTopEdge = finalTop - panelHalfHeight;
          const panelBottomEdge = finalTop + panelHalfHeight;
          const wrapperWidth = wrapper ? wrapper.offsetWidth : window.innerWidth;
          const container = document.getElementById("timeline");
          const axisX = container && container.dataset.axisX ? parseFloat(container.dataset.axisX) : wrapperWidth / 2;
          const cardEl = document.querySelector(`.event-card[data-event-id="${eventId}"]`);
          const cardHeight = cardEl ? cardEl.offsetHeight : 0;
          const cardRect = cardEl
            ? {
                left: e.cardLeft,
                right: e.cardLeft + (e.cardWidth || cardEl.offsetWidth || 0),
                top: e.labelCenter - cardHeight / 2,
                bottom: e.labelCenter + cardHeight / 2
              }
            : null;

          const detailRectRaw =
            panelHeight && panel.offsetWidth
              ? {
                  left: e.detailLeft,
                  right: e.detailLeft + panel.offsetWidth,
                  top: finalTop - panelHalfHeight,
                  bottom: finalTop + panelHalfHeight
                }
              : null;

          const detailRectCenterX = detailRectRaw
            ? (detailRectRaw.left + detailRectRaw.right) / 2
            : detailCenterX;
          const effectiveWrapperHeight = wrapperHeight || window.innerHeight || panelHeight || baseHeight;
          const wrapperMidY = effectiveWrapperHeight / 2;
          const preferLeftPlacement = detailRectCenterX >= axisX;
          const preferAbovePlacement = finalTop >= wrapperMidY;
          let placeMediaToLeft = preferLeftPlacement;

          const minAllowedX = detailMediaEdgeMargin - detailMediaBoundaryOverflow;
          const maxAllowedX = wrapperWidth - detailMediaEdgeMargin + detailMediaBoundaryOverflow;
          const leftExtent = e.detailLeft - detailMediaGap - baseWidth;
          const rightExtent = e.detailLeft + detailWidth + detailMediaGap + baseWidth;
          const hasLeftSpace = leftExtent >= minAllowedX;
          const hasRightSpace = rightExtent <= maxAllowedX;
          if (placeMediaToLeft && !hasLeftSpace && hasRightSpace) placeMediaToLeft = false;
          if (!placeMediaToLeft && !hasRightSpace && hasLeftSpace) placeMediaToLeft = true;

          const expandRect = (rect, margin = 0) =>
            rect
              ? {
                  left: rect.left - margin,
                  right: rect.right + margin,
                  top: rect.top - margin,
                  bottom: rect.bottom + margin
                }
              : null;

          const conflictMargin = 18;
          const cardRectExpanded = expandRect(cardRect, conflictMargin);
          const detailRectExpanded = expandRect(detailRectRaw, conflictMargin);

          const buildMediaRect = centerY => {
            const top = centerY - baseHeight / 2;
            const bottom = centerY + baseHeight / 2;
            if (placeMediaToLeft) {
              const anchor = e.detailLeft - detailMediaGap;
              return {
                left: anchor - baseWidth,
                right: anchor,
                top,
                bottom
              };
            }
            const anchor = e.detailLeft + detailWidth + detailMediaGap;
            return {
              left: anchor,
              right: anchor + baseWidth,
              top,
              bottom
            };
          };

          const intersects = (a, b) => {
            if (!a || !b) return false;
            return !(a.right <= b.left || a.left >= b.right || a.bottom <= b.top || a.top >= b.bottom);
          };

          const overlapArea = (a, b) => {
            if (!a || !b) return 0;
            const width = Math.max(0, Math.min(a.right, b.right) - Math.max(a.left, b.left));
            const height = Math.max(0, Math.min(a.bottom, b.bottom) - Math.max(a.top, b.top));
            return width * height;
          };

          let placedHorizontally = false;
          if (wrapperWidth && wrapperHeight) {
            const minCenterY = detailMediaEdgeMargin - detailMediaBoundaryOverflow + baseHeight / 2;
            const maxCenterY = wrapperHeight - detailMediaEdgeMargin + detailMediaBoundaryOverflow - baseHeight / 2;
            const clampCenter = y => Math.min(Math.max(y, minCenterY), maxCenterY);

            const candidateCenters = [];
            const pushCandidate = val => {
              if (Number.isFinite(val)) candidateCenters.push(clampCenter(val));
            };

            pushCandidate(finalTop);
            if (detailRectRaw) {
              pushCandidate(detailRectRaw.top - detailMediaVerticalGap - baseHeight / 2);
              pushCandidate(detailRectRaw.bottom + detailMediaVerticalGap + baseHeight / 2);
            }
            if (cardRect) {
              pushCandidate(cardRect.top - detailMediaVerticalGap - baseHeight / 2);
              pushCandidate(cardRect.bottom + detailMediaVerticalGap + baseHeight / 2);
            }

            const uniqueCenters = [];
            candidateCenters.forEach(center => {
              if (!uniqueCenters.some(existing => Math.abs(existing - center) < 0.5)) {
                uniqueCenters.push(center);
              }
            });

            const preferredTarget = detailRectRaw
              ? preferAbovePlacement
                ? detailRectRaw.top - detailMediaVerticalGap - baseHeight / 2
                : detailRectRaw.bottom + detailMediaVerticalGap + baseHeight / 2
              : preferAbovePlacement
              ? finalTop - detailMediaVerticalGap - baseHeight / 2
              : finalTop + detailMediaVerticalGap + baseHeight / 2;
            const weightCenter = center => {
              const ref = Number.isFinite(preferredTarget) ? preferredTarget : finalTop;
              const wrongSidePenalty = preferAbovePlacement
                ? center > finalTop
                  ? detailMediaAbovePenalty
                  : 0
                : center < finalTop
                ? detailMediaAbovePenalty
                : 0;
              return Math.abs(center - ref) + wrongSidePenalty;
            };

            uniqueCenters.sort((a, b) => weightCenter(a) - weightCenter(b));

            const evaluateOverlap = center => {
              const rect = buildMediaRect(center);
              return overlapArea(rect, cardRectExpanded) + overlapArea(rect, detailRectExpanded);
            };

            let chosenCenter = uniqueCenters.length ? uniqueCenters[0] : clampCenter(finalTop);
            let minOverlap = Infinity;

            for (const center of uniqueCenters) {
              const rect = buildMediaRect(center);
              const overlaps =
                (cardRectExpanded && intersects(rect, cardRectExpanded)) ||
                (detailRectExpanded && intersects(rect, detailRectExpanded));
              const overlapScore = evaluateOverlap(center);
              if (!overlaps) {
                chosenCenter = center;
                minOverlap = 0;
                break;
              }
              if (overlapScore < minOverlap) {
                minOverlap = overlapScore;
                chosenCenter = center;
              }
            }

            setSize(baseWidth, baseHeight);
            if (placeMediaToLeft) {
              const anchor = e.detailLeft - detailMediaGap;
              mediaPanel.style.left = anchor + "px";
              mediaPanel.style.transform = "translate(-100%, -50%)";
            } else {
              const anchor = e.detailLeft + detailWidth + detailMediaGap;
              mediaPanel.style.left = anchor + "px";
              mediaPanel.style.transform = "translateY(-50%)";
            }
            mediaPanel.style.top = chosenCenter + "px";
            placedHorizontally = true;
          }

          if (!placedHorizontally) {
            const marginWithOverflow = detailMediaEdgeMargin - detailMediaBoundaryOverflow;
            const spaceAbove = panelTopEdge - marginWithOverflow - detailMediaVerticalGap;
            const spaceBelow = wrapperHeight - panelBottomEdge - marginWithOverflow - detailMediaVerticalGap;
            const canPlaceAbove = spaceAbove > 0;
            const canPlaceBelow = spaceBelow > 0;
            let placeAbove;
            if (preferAbovePlacement && canPlaceAbove) {
              placeAbove = true;
            } else if (!preferAbovePlacement && canPlaceBelow) {
              placeAbove = false;
            } else {
              placeAbove = spaceAbove >= spaceBelow;
            }
            const availableHeight = placeAbove ? spaceAbove : spaceBelow;
            const availableWidth = wrapperWidth - detailMediaEdgeMargin * 2;
            buildSizeWithPreferredHeight(availableWidth, availableHeight);
            setSize(baseWidth, baseHeight);

            let centerX = detailCenterX;
            const halfWidth = baseWidth / 2;
            if (placeMediaToLeft) {
              const maxCenter = detailRectRaw
                ? detailRectRaw.left - detailMediaGap - halfWidth
                : detailCenterX - detailMediaGap;
              centerX = Math.min(centerX, maxCenter);
              centerX = Math.max(detailMediaEdgeMargin + halfWidth, centerX);
            } else {
              const minCenter = detailRectRaw
                ? detailRectRaw.right + detailMediaGap + halfWidth
                : detailCenterX + detailMediaGap;
              centerX = Math.max(centerX, minCenter);
              centerX = Math.min(wrapperWidth - detailMediaEdgeMargin - halfWidth, centerX);
            }

            let centerY;
            if (placeAbove) {
              centerY = panelTopEdge - detailMediaVerticalGap - baseHeight / 2;
            } else {
              centerY = panelBottomEdge + detailMediaVerticalGap + baseHeight / 2;
            }
            const minCenterY = detailMediaEdgeMargin - detailMediaBoundaryOverflow + baseHeight / 2;
            const maxCenterY = wrapperHeight - detailMediaEdgeMargin + detailMediaBoundaryOverflow - baseHeight / 2;
            centerY = Math.min(Math.max(centerY, minCenterY), maxCenterY);

            mediaPanel.style.left = centerX + "px";
            mediaPanel.style.top = centerY + "px";
            mediaPanel.style.transform = "translate(-50%, -50%)";
          }

          mediaPanel.style.opacity = "1";
        }
      }
    }

    function applyActive(eventId) {
      const container = document.getElementById("timeline");
      const pieces = container.querySelectorAll(".event-piece");
      if (!pieces.length) return;

      if (currentActiveId === eventId) return;
      currentActiveId = eventId;

      pieces.forEach(el => {
        if (!eventId) {
          el.classList.remove("active", "dimmed");
        } else if (el.dataset.eventId === eventId) {
          el.classList.add("active");
          el.classList.remove("dimmed");
        } else {
          el.classList.add("dimmed");
          el.classList.remove("active");
        }
      });

      updateDetailPanel(eventId);
    }

    function setupHover() {
      const container = document.getElementById("timeline");

      container.addEventListener("mousemove", e => {
        const target = e.target.closest(".event-card, .event-line-core, .leader-line, .date-label");
        if (target && target.dataset.eventId) {
          applyActive(target.dataset.eventId);
        } else {
          applyActive(null);
        }
      });

      container.addEventListener("mouseleave", () => {
        applyActive(null);
      });
    }

    function buildTimeline() {
      const container = document.getElementById("timeline");
      container.innerHTML = "";
      renderedEvents = [];
      currentActiveId = null;
      updateDetailPanel(null);
      measureDetailHeights();

      const now = new Date();
      const nowMonthIndex = monthIndexFromDate(now);
      const ongoingPadUnits = 3;

      // Parse events and represent them in month units
      const parsed = events.map((e, idx) => {
        const startDate = parseDate(e.start);
        const endDate = e.end ? parseDate(e.end) : now;
        const isOngoing = !e.end;

        const startMonth = monthIndexFromDate(startDate); // inclusive
        const endMonthBase = monthIndexFromDate(endDate);
        const endUnit = isOngoing ? nowMonthIndex + 1 + ongoingPadUnits : endMonthBase; // ongoing takes extra space

        return {
          ...e,
          startDate,
          endDate,
          isOngoing,
          startMonth,
          endMonthBase,
          startUnit: startMonth,
          endUnit,
          index: idx,
          detailHeight: detailHeights[idx] || 0
        };
      });

      const minUnit = parsed.reduce(
        (acc, e) => Math.min(acc, e.startUnit),
        parsed[0].startUnit
      );
      const maxUnit = parsed.reduce(
        (acc, e) => Math.max(acc, e.endUnit),
        parsed[0].endUnit
      );

      const wrapper = container.parentElement;
      const pixelsPerUnit = 36;
      const baseTopPadding = -260;
      const baseBottomPadding = -400;
      const maxDetailHeight = parsed.reduce(
        (acc, e) => Math.max(acc, e.detailHeight || 0),
        0
      );
      const detailVerticalMargin = 24;
      const fallbackDetailHeight = 280;
      const measuredHalf = maxDetailHeight ? maxDetailHeight / 2 : 0;
      const detailHalfSpan = Math.max(measuredHalf, fallbackDetailHeight / 2) + detailVerticalMargin;

      const totalUnits = maxUnit - minUnit || 1;
      const baseSpan = totalUnits * pixelsPerUnit;
      const topPadding = baseTopPadding + detailHalfSpan;
      const bottomPadding = baseBottomPadding + detailHalfSpan;
      const computedHeight = topPadding + bottomPadding + baseSpan;
      wrapper.style.height = computedHeight + "px";
      wrapper.dataset.timelineHeight = computedHeight;

      const height = wrapper.offsetHeight || computedHeight;
      const usableHeight = height - topPadding - bottomPadding;

      const axisX = container.offsetWidth / 2;
      container.dataset.axisX = axisX;
      function mapUnitToY(unit) {
        const ratio = (unit - minUnit) / totalUnits;
        return topPadding + ratio * usableHeight;
      }

      // Timeline ticks: monthly + yearly
      const minMonthIdx = minUnit;
      const maxMonthIdxForTicks = parsed.reduce(
        (acc, e) => {
          const endpoint = e.isOngoing ? e.endUnit : e.endMonthBase;
          return Math.max(acc, endpoint);
        },
        parsed[0].endMonthBase
      );

      for (let idx = minMonthIdx; idx <= maxMonthIdxForTicks; idx++) {
        const y = mapUnitToY(idx);
        const month = monthFromMonthIndex(idx);
        const year = yearFromMonthIndex(idx);
        if (year >= 2026 && month !== 0) continue;

        const tick = document.createElement("div");
        tick.className = "time-tick event-piece";
        tick.style.top = `${y}px`;

        if (month === 0) {
          tick.classList.add("time-tick-year");
          const label = document.createElement("div");
          label.className = "time-tick-label-year";
          label.textContent = `${year}`;
          tick.appendChild(label);
        } else {
          tick.classList.add("time-tick-month");
          const label = document.createElement("div");
          label.className = "time-tick-label-month";
          label.textContent = `${month + 1}`;
          tick.appendChild(label);
        }

        container.appendChild(tick);
      }

      // Compute vertical positions from month units
      parsed.forEach(e => {
        const top = mapUnitToY(e.startUnit);
        const bottom = mapUnitToY(e.endUnit);
        e.lineTop = top;
        e.lineBottom = bottom;
        e.lineHeight = bottom - top;
        const manualShift = e.cardOffset || 0;
        e.centerRaw = (top + bottom) / 2 + manualShift;
      });

      // Date label text and jitter to reduce overlap for identical labels
      parsed.forEach(e => {
        e.startLabelText = formatDateLabel(e.startDate);
        e.endLabelText = e.isOngoing ? "present" : formatDateLabel(e.endDate);
      });

      const labelGroups = {};
      parsed.forEach(e => {
        const sKey = e.startLabelText;
        (labelGroups[sKey] = labelGroups[sKey] || []).push({ event: e, type: "start" });
        const eKey = e.endLabelText;
        (labelGroups[eKey] = labelGroups[eKey] || []).push({ event: e, type: "end" });
      });

      const jitter = 10;
      Object.values(labelGroups).forEach(group => {
        if (group.length <= 1) return;
        group.forEach((entry, index) => {
          const offset = (index - (group.length - 1) / 2) * jitter;
          if (entry.type === "start") entry.event.startLabelOffsetY = offset;
          else entry.event.endLabelOffsetY = offset;
        });
      });

      // De-overlap card centers
      const labelInfos = parsed
        .map(e => ({ index: e.index, centerRaw: e.centerRaw }))
        .sort((a, b) => a.centerRaw - b.centerRaw);

      const minGap = 80;
      let lastY = -Infinity;
      labelInfos.forEach(info => {
        let y = info.centerRaw;
        if (y - lastY < minGap) y = lastY + minGap;
        parsed[info.index].labelCenter = y;
        lastY = y;
      });

      // Alternate sides (left/right)
      parsed.forEach((e, idx) => {
        e.side = idx % 2 === 0 ? "left" : "right";
      });

      const cardWidth = 260;
      const gap = 40;
      const dateLabelOffset = 20;
      const detailWidth = 420;
      const detailGap = 24;

      // Render each event
      parsed.forEach((e, idx) => {
        const eventId = "e-" + idx;
        e.eventId = eventId;
        renderedEvents.push(e);

        const lineClusterOffset = (idx - (parsed.length - 1) / 2) * 6;
        const lineX = axisX + lineClusterOffset;

        // Line segment
        const line = document.createElement("div");
        line.className = "event-line-core event-piece";
        line.style.setProperty("--color", e.color);
        line.style.left = (lineX - 3) + "px";
        line.style.top = e.lineTop + "px";
        line.style.height = e.lineHeight + "px";
        line.dataset.eventId = eventId;
        container.appendChild(line);

        // Start date pill
        const startLabelY = e.lineTop + (e.startLabelOffsetY || 0);
        const startLabel = document.createElement("div");
        startLabel.className = "date-label event-piece";
        startLabel.textContent = e.startLabelText;
        const startLabelOnRight = e.side === "left";
        const startLabelX = startLabelOnRight ? lineX + dateLabelOffset : lineX - dateLabelOffset;
        startLabel.style.left = startLabelX + "px";
        startLabel.style.top = startLabelY + "px";
        startLabel.style.transform = startLabelOnRight ? "translateY(-50%)" : "translate(-100%, -50%)";
        startLabel.dataset.eventId = eventId;
        container.appendChild(startLabel);

        // End date pill
        const endLabelY = e.lineBottom + (e.endLabelOffsetY || 0);
        const endLabel = document.createElement("div");
        endLabel.className = "date-label event-piece";
        endLabel.textContent = e.endLabelText;
        const endLabelOnRight = e.side === "left";
        const endLabelX = endLabelOnRight ? lineX + dateLabelOffset : lineX - dateLabelOffset;
        endLabel.style.left = endLabelX + "px";
        endLabel.style.top = endLabelY + "px";
        endLabel.style.transform = endLabelOnRight ? "translateY(50%)" : "translate(-100%, 50%)";
        endLabel.dataset.eventId = eventId;
        container.appendChild(endLabel);

        // Summary card
        const card = document.createElement("div");
        card.className = "event-card event-piece";
        card.style.setProperty("--color", e.color);
        card.style.backgroundColor = hexToRgba(e.color, 0.10);
        card.style.borderColor = hexToRgba(e.color, 0.35);
        card.style.top = e.labelCenter + "px";

        let cardLeft;
        if (e.side === "left") cardLeft = axisX - gap - cardWidth;
        else cardLeft = axisX + gap;

        card.style.left = cardLeft + "px";
        card.dataset.eventId = eventId;
        e.cardLeft = cardLeft;
        e.cardWidth = cardWidth;

        // Institution pills
        if (e.institutions && e.institutions.length) {
          const instRow = document.createElement("div");
          instRow.className = "event-institutions";
          e.institutions.forEach(name => {
            const pill = document.createElement("span");
            pill.className = "inst-pill";
            pill.textContent = name;
            pill.style.backgroundColor = hexToRgba(e.color, 0.18);
            pill.style.borderColor = hexToRgba(e.color, 0.6);
            instRow.appendChild(pill);
          });
          card.appendChild(instRow);
        }

        const titleEl = document.createElement("div");
        titleEl.className = "event-title";
        titleEl.textContent = e.title;

        const subtitleEl = document.createElement("div");
        subtitleEl.className = "event-subtitle";
        subtitleEl.textContent = e.subtitle;

        const datesEl = document.createElement("div");
        datesEl.className = "event-dates";
        datesEl.textContent = e.label;

        card.appendChild(titleEl);
        card.appendChild(subtitleEl);
        card.appendChild(datesEl);
        container.appendChild(card);

        // Leader line
        const leader = document.createElement("div");
        leader.className = "leader-line event-piece";
        leader.style.setProperty("--color", e.color);
        leader.dataset.eventId = eventId;

        const anchorY = Math.max(
          e.lineTop + 4,
          Math.min(e.lineBottom - 4, e.labelCenter)
        );
        leader.style.top = anchorY + "px";

        if (e.side === "left") {
          const cardRight = cardLeft + cardWidth;
          const leaderLeft = cardRight + 4;
          const leaderRight = lineX;
          leader.style.left = leaderLeft + "px";
          leader.style.width = (leaderRight - leaderLeft) + "px";
        } else {
          const leaderLeft = lineX + 4;
          const leaderRight = cardLeft - 4;
          leader.style.left = leaderLeft + "px";
          leader.style.width = (leaderRight - leaderLeft) + "px";
        }
        container.appendChild(leader);

        // Floating detail panel placement (always outside the card)
        let detailLeft;
        if (e.side === "left") detailLeft = cardLeft - detailWidth - detailGap;
        else detailLeft = cardLeft + cardWidth + detailGap;

        e.detailLeft = detailLeft;
        e.detailTop = e.labelCenter;
        e.detailWidth = detailWidth;
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      buildTimeline();
      setupHover();
    });

    window.addEventListener("resize", buildTimeline);
  </script>
</body>
</html>
